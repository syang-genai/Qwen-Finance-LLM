import re
def validate_startup_investment_response(response: str) -> dict:
    """
    Validates if a generated startup investment evaluation response follows the
    specified format from the system prompt.

    Args:
        response (str): The full text generated by the language model.

    Returns:
        dict: A dictionary containing:
            'is_valid': bool - True if the format is followed, False otherwise.
            'errors': list[str] - A list of detailed error messages if validation fails.
            'parsed_data': dict - A dictionary containing extracted 'think_content',
                           'decision', and 'explanation' if successfully parsed.
    """
    errors = []
    is_valid = True
    parsed_data = {
        "think_content": None,
        "decision": None,
        "explanation": None
    }

    # 1. Check for the presence and content of the <think>...</think> block
    # re.DOTALL allows '.' to match newlines
    think_block_match = re.search(r"<think>(.*?)</think>", response, re.DOTALL)

    if not think_block_match:
        errors.append("Missing or malformed <think>...</think> block.")
        is_valid = False
    else:
        think_content = think_block_match.group(1).strip()
        parsed_data["think_content"] = think_content

        # Check for forbidden keywords inside <think>
        if "DECISION:" in think_content or "EXPLANATION:" in think_content:
            errors.append("DECISION: or EXPLANATION: found inside <think> block, which is forbidden.")
            is_valid = False

        # Get the remaining part of the response after the </think> block
        post_think_segment = response[think_block_match.end():].strip()

        # 2. Check for DECISION: line
        # Use re.IGNORECASE for robustness, though prompt implies exact casing
        decision_line_match = re.search(r"DECISION:\s*\[(Invest|Do not invest)\]", post_think_segment, re.IGNORECASE)

        if not decision_line_match:
            errors.append("Missing or malformed 'DECISION: [Invest]' or 'DECISION: [Do not invest]' line after <think> block.")
            is_valid = False
        else:
            parsed_data["decision"] = decision_line_match.group(1).strip()
            
            # Get the remaining part of the response after the DECISION line
            post_decision_segment = post_think_segment[decision_line_match.end():].strip()

            # 3. Check for EXPLANATION: line
            explanation_line_match = re.search(r"EXPLANATION:\s*(.+)", post_decision_segment, re.DOTALL)

            if not explanation_line_match:
                errors.append("Missing or malformed 'EXPLANATION:' line after DECISION.")
                is_valid = False
            else:
                explanation_text = explanation_line_match.group(1).strip()
                parsed_data["explanation"] = explanation_text

                # 4. Check explanation length (1-2 sentences)
                # This is a heuristic and can be adjusted based on strictness.
                # It handles common punctuation but might be imperfect for all edge cases.
                sentences = [s for s in re.split(r'[.!?](?:\s+|$)', explanation_text) if s.strip()]
                if not (1 <= len(sentences) <= 2):
                    errors.append(f"Explanation is not 1-2 sentences long. Found {len(sentences)} sentences.")
                    # Depending on strictness, you might allow this and just warn, or fail validation.
                    is_valid = False
                
                # 5. Check for any extraneous content after the EXPLANATION
                remaining_content_after_explanation = post_decision_segment[explanation_line_match.end():].strip()
                if remaining_content_after_explanation:
                    errors.append(f"Extraneous content found after EXPLANATION: '{remaining_content_after_explanation[:100]}...'")
                    is_valid = False
    
    # If any errors were found, the response is invalid
    if errors:
        is_valid = False

    return {
        "is_valid": is_valid,
        "errors": errors,
        "parsed_data": parsed_data
    }